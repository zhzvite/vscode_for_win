## 欧拉函数(euler function )
旨在求出一个数n的1-n中与n互质的数的个数 
1.首先从1-N中去掉p1,p2,....pk的所有的倍数 2.加上所有pi*pj的倍数,因为减重复了 3.减去所有pi*pj*pk的倍数......(利用的是容斥原理)
**时间复杂度*根号n**分解质因数的时间复杂度是根号n

# DP(动态规划)
# 性质(动态规划和递推的区别)
递推求出的是数据，所以只是针对数据进行操作；而动态规划求出的是最优状态，所以必然也是针对状态的操作，而状态自然可以出现在最优解中，也可以不出现——这便是决策的特性（布尔性）。

其次，由于每个状态均可以由之前的状态演变形成，所以动态规划有可推导性，但同时，动态规划也有无后效性，即每个当前状态会且仅会决策出下一状态，而不直接对未来的所有状态负责，可以浅显的理解为——

***Future  never  has  to  do  with  past  time  ,but  present  does._***
现在决定未来，未来与过去无关

## 背包 
二维的状态转移方程**dp[i][j]=max{dp[i-1][j],dp[i-1][v-c[i]]+w[i]};**

优化空间复杂度 
**dp[j]=max{dp[j],dp[j-c[i]]+w[i]};**

 初始化的细节问题 
**在初始化时,观察题目若是要求恰好装满背包的最优解,则应该将dp[1,2,3,...v]全部初始化成-∞,因为其他容量背包没有合法的解** 
**而价格尽量大,则应该只把dp[0]设置为0**

### 完全背包问题的优化 
对数据进行取舍,选物美价廉的商品,排除大于容量的商品
**二进制优化** 

## 线性dp
### 1. 数字三角形(入门)
**动态规划思路分析1. 状态表示(集合和集合的属性(Max||Min)) 2.状态计算(状态转移方程)**
动态规划时间复杂度:状态数量*转移的计算量
*注意点* (多做题,积累经验)
1.初始化要考虑边界问题,每行多初始化一个
2.题目要求要从最上层到最底层的最大路径,要考虑到数字可以为负数(故要初始化为-∞)
![Alt text](../photo/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2.png)

### 2. 最长上升子序列(求的是数值严格单调递增的子序列最大长度) 
集合:所有以第i个数字结尾的上升子序列 属性:所有以该数字结尾的最大序列的最大长度
状态转移方程:(以第i-1个数字来分类)(分类方式是难点)  
**最长上升子序列优化版本** 
### 设 dp[i] 表示长度为 i 的最长上升子序列的末尾元素的最小值，显然这个数组的权值一定单调不降。于是我们按顺序枚举数组nums，每一次对dp数组二分查找，找到小于nums[i]的最大的 dp[j]，并更新 dp[j+1]。


 
### 3. 最长公共子序列(给模式串A和B,求出又是A的子序列又是B的子序列的最长序列)
1.状态表示两纬dp[i,j]  (所有由第一个序列的前i个字母和第二个序列的前j个字母构成的子序列)
其分的四个类虽然有重叠,但没有遗漏,dp[i,j]表示的是考虑第一个序列前i个,第二个序列前j个出现的子序列但a[i],b[j]只是以这两个结尾的子序列,并且这四个类中第二三个类可以把第一个彻底涵盖,故在平常只写三种情况的dp
![Alt text](../photo/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1.png)

### 4.区间dp-石子合并 (将n堆石子合并为一堆,每次合并相邻两堆石子,合并的代价是两堆石子的质量和,求最小代价)(0(n^3))
集合:所有将第i堆到第j堆石子合并成一堆石子的合并方式,将这么多方式分成k类,是将每一类的最小代价取min
转移方程
```
 dp[l][r]=min(dp[l][r],dp[l][k]+dp[k+1][r]+s[r]-s[l-1]);//其中k是起到中介作用,将大区间划分成小区间
```
从小区间开始枚举,k充当的是划分区间的作用,将大区间划分成小区间,通过循环一直更新,递推,最后更新到dp[1][n];
要记住k是从i开始,到r-1结束,因为要保证k是第l到r之间的一个分割点

### 最短编辑距离 (n^2)
集合:所有将a[1-i]变成b[1-j]的操作方式,以空间换时间
dp[i][j]表示的是将a的前i个字符变成b的前j个字符需要的最少操作次数,有三种类
![Alt text](../photo/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.png)


## 计数类dp
### 整数划分(将一个正整数划分成多个正整数之和(不考虑顺序)求划分方式)
集合:f[i,j]从1-i中选,符合数量为j的选法,可以看作是完全背包问题



(数位dp)
计数问题:统计[a-b]中[0-9]出现的次数
**分情况讨论**~~感觉分情况讨论在哪都是一种好的思维方式~~ 转化成一个count(n,x),求1-n中x出现的次数 前缀和思路{count(b,x)-count(a-1,x)};x取遍0-9,
![Alt text](../photo/%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98.png)  
  
### 状压dp(用一个整数,表示一个所有的状态,但最多到20个表示)
### 蒙德里安的梦想: dp[i][j],所有摆到了第i列,,上一列伸出的小正方形为j(通过二进制表示每一行)的所有方案数 
方程:要判断上一个状态能否转移
条件一: 从i-1列升到i列与i-2列升到i-1列不冲突,及(k&j==0)
条件二: j^k不存在连续奇数个0;(可以预处理)

#### hamilton最短路径
算是二维的状态压缩dp,以二进制表示所有经过的点  
dp[i][j]表示从0-j,中间走过的所有点是i,i表示的是一种状态,通过20位二进制数的0/1组合来达到走过和没走过的效果
要取最小值 ,

## 树形dp
## 没有上司的舞会  
状态表示有两个,分为dp[u,0],dp[u,1],分别指,在以u为根的tree中选,并且(不选/选)u的最大快乐值
值的属性是: max 

采用递归打法


## 记忆化搜索
记忆化搜索是dp的一种实现方式(但注意递归的层数过多可能会暴栈)
采取递归的方式构成循环,模板题洛谷p1434
https://www.luogu.com.cn/problem/P1434
